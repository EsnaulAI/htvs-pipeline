configfile: 'config/config.yaml'

# --- LÓGICA PRELIMINAR ---
USE_MMSEQS = config["evolution"].get("use_mmseqs", False)

def get_ligands_from_list():
    list_path = checkpoints.generate_ligands_list.get().output.list
    with open(list_path, "r") as handle:
        return [line.strip() for line in handle if line.strip()]


def get_ligands(wildcards):
    return get_ligands_from_list()

# --- REGLA MAESTRA GLOBAL ---
rule all:
    input:
        # Módulo 1: Target
        "results/module1/candidate_ranking.csv",
        "results/module1/view_scene.cxc",
        "results/module1/config_updated.flag",

        # Módulo 2: Ligandos
        "results/module2/preparation_done.flag",
        "results/module2/ligands_list.txt",
        "results/module2/qc_report.csv",
        "results/module2/library_dedup.smi",
        "results/module2/library_enumerated.smi",

        # Módulo 3: Docking y Consenso
        "results/module3/docking_scores.csv",
        "results/module3/top_candidates.csv",
        "results/module3/gnina_scores.csv",
        "results/module3/final_hits.csv",
        "results/module3/consensus_final.csv",
        "results/final_report.txt",
        "results/module3/vina",
        "results/module3/vina_logs",
        lambda wc: expand(
            "results/module3/ligands_pdbqt/{ligand}.pdbqt",
            ligand=get_ligands_from_list(),
        )

# =========================================
# MÓDULO 1: INTELIGENCIA BIOLÓGICA
# =========================================

rule fetch_clean_pdb:
    conda: "../environment.yaml"
    output:
        pdb=config["structure"]["clean_pdb"],
        fasta="results/module1/target.fasta"
    params:
        pdb_id=config["structure"]["pdb_id"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/module1_prep_structure.py'

if not USE_MMSEQS:
    rule run_blast:
        conda: "../environment.yaml"  # Biopython (BLAST remoto) vive en el env principal
        input: fasta="results/module1/target.fasta"
        output:
            xml="results/module1/blast_results.xml",
            fasta_homologs=config["evolution"]["unaligned_homologs"],
            method_log="results/module1/homolog_method.log"
        params:
            n_hits=config["evolution"]["n_homologs"],
            e_val=config["evolution"]["e_value"],
            db=config["evolution"].get("blast_db", "nr")
        script: 'scripts/module1_run_blast.py'
else:
    rule run_mmseqs:
        conda: "envs/mmseqs.yaml"
        input: fasta="results/module1/target.fasta"
        output:
            fasta_homologs=config["evolution"]["unaligned_homologs"],
            method_log="results/module1/homolog_method.log"
        threads: 4
        script: 'scripts/module1_run_mmseqs.py'

rule parse_and_align:
    conda: "envs/mafft.yaml"
    input:
        homologs=config["evolution"]["unaligned_homologs"],
        original_fasta="results/module1/target.fasta"
    output: fasta_msa=config["evolution"]["msa_file"]
    threads: 4
    script: 'scripts/module1_parse_and_align.py'

rule msa_qc:
    conda: "../environment.yaml"
    input: msa=config["evolution"]["msa_file"]
    output: report=config["evolution"]["msa_qc_report"]
    script: 'scripts/module1_msa_qc.py'

rule map_conservation:
    conda: "../environment.yaml"
    input:
        pdb=config["structure"]["clean_pdb"],
        msa=config["evolution"]["msa_file"],
        qc_report=config["evolution"]["msa_qc_report"]
    output:
        pdb_conserved=config["evolution"]["conservation_pdb"],
        pdb_msa_map=config["evolution"]["pdb_msa_map"]
    script: 'scripts/module1_map_entropy.py'

rule run_pydca:
    conda: "envs/pydca.yaml"
    input:
        msa=config["evolution"]["msa_file"],
        pdb_msa_map=config["evolution"]["pdb_msa_map"]
    output:
        plot="results/module1/dca_distribution.png",
        report="results/module1/dca_top_contacts.csv"
    params: target_res=config["structure"]["target_residue"]
    script: 'scripts/module1_pydca.py'

rule run_coevolution_mi:
    input:
        msa=config["evolution"]["msa_file"],
        pdb_msa_map=config["evolution"]["pdb_msa_map"]
    output: plot="results/module1/coevolution_profile.png"
    params: target_res=config["structure"]["target_residue"]
    script: 'scripts/module1_coevolution_mi.py'

rule run_network_analysis:
    conda: "../environment.yaml"
    input: pdb=config["evolution"]["conservation_pdb"]
    output: report="results/module1/network_report.txt"
    params:
        target_res=config["structure"]["target_residue"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/module1_network_analysis.py'

rule run_nma:
    conda: "../environment.yaml"
    input: pdb=config["evolution"]["conservation_pdb"]
    output: plot="results/module1/nma_mobility_profile.png"
    params:
        target_res=config["structure"]["target_residue"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/module1_nma_check.py'

rule check_druggability:
    conda: "../environment.yaml"
    input: pdb=config["structure"]["clean_pdb"]
    output: report="results/module1/druggability_report.txt"
    params:
        chain=config["structure"]["chain_id"],
        target_res=config["structure"]["target_residue"]
    script: 'scripts/module1_check_druggability.py'

rule run_fpocket:
    conda: "envs/fpocket.yaml"
    input: pdb=config["structure"]["clean_pdb"]
    output: info="results/module1/pockets/target_clean_info.txt"
    shell:
        """
        fpocket -f {input.pdb}
        mkdir -p results/module1/pockets
        mv results/module1/target_clean_out/target_clean_info.txt {output.info}
        rm -rf results/module1/target_clean_out
        """

rule prepare_receptor_phys:
    conda: "envs/openbabel.yaml"
    input: pdb=config["structure"]["clean_pdb"]
    output: pdbqt="results/module1/target_prepared.pdbqt"
    log: "logs/module1/prepare_receptor_phys.log"
    shell:
        """
        set -euo pipefail
        mkdir -p $(dirname {log})
        tmp_dir=$(mktemp -d)
        cleanup() {{ rm -rf "$tmp_dir"; }}
        trap cleanup EXIT
        tmp_pdb="$tmp_dir/receptor_preprocessed.pdb"
        tmp_mol2="$tmp_dir/receptor_preprocessed.mol2"

        python workflow/scripts/preprocess_receptor.py {input.pdb} "$tmp_pdb" 2> {log}
        obabel "$tmp_pdb" -O "$tmp_mol2" --addtotitle "receptor_prepared" --neutralize -p 7.4 2>> {log}
        obabel "$tmp_mol2" -O {output.pdbqt} -xr --partialcharge gasteiger -p 7.4 --addtotitle "receptor_prepared" 2>> {log}
        """

rule discover_best_candidate:
    conda: "../environment.yaml"
    input:
        pdb=config["evolution"]["conservation_pdb"],
        pockets="results/module1/pockets/target_clean_info.txt"
    output: csv="results/module1/candidate_ranking.csv"
    params: chain=config["structure"]["chain_id"]
    script: 'scripts/module1_discover_best_target.py'

rule update_target_config:
    conda: "../environment.yaml"
    input:
        csv="results/module1/candidate_ranking.csv",
        pdb=config["structure"]["clean_pdb"]
    output: touch("results/module1/config_updated.flag")
    params: chain=config["structure"]["chain_id"]
    script: 'scripts/bridge_update_config.py'

rule generate_viz:
    conda: "../environment.yaml"
    input: pdb=config["evolution"]["conservation_pdb"]
    output: cxc="results/module1/view_scene.cxc"
    params:
        target_res=config["structure"]["target_residue"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/generate_chimerax_scene.py'


# =========================================
# MÓDULO 2: QUIMIOINFORMÁTICA
# =========================================

rule fetch_library:
    conda: "../environment.yaml"
    output: smi=config["chemistry"]["raw_library"]
    script: 'scripts/fetch_chembl_drugs.py'

rule filter_ligands:
    conda: "envs/rdkit.yaml"
    input: smi=config["chemistry"]["raw_library"]
    output:
        filtered=config["chemistry"]["filtered_library"],
        report="results/module2/filtering_report.csv",
        dedup="results/module2/library_dedup.smi"
    params:
        mw=config["chemistry"]["filters"]["mw_max"],
        logp=config["chemistry"]["filters"]["logp_max"],
        amine=config["chemistry"]["filters"]["must_have_amine"]
    script: 'scripts/module2_filter_entry.py'

rule qc_properties:
    conda: "envs/rdkit.yaml"
    input: smi=config["chemistry"]["filtered_library"]
    output: report="results/module2/qc_report.csv"
    script: 'scripts/module2_qc_properties.py'

rule enumerate_protomers:
    conda: "envs/rdkit.yaml"
    input: smi="results/module2/library_dedup.smi"
    output: enumerated="results/module2/library_enumerated.smi"
    script: 'scripts/module2_enumerate_protomers.py'

rule prepare_ligands_3d:
    conda: "envs/rdkit.yaml"
    input: smi="results/module2/library_enumerated.smi"
    output: touch("results/module2/preparation_done.flag")
    params: out_dir=config["chemistry"]["prepared_dir"]
    threads: 4
    script: 'scripts/module2_prep_3d.py'


checkpoint generate_ligands_list:
    input:
        flag="results/module2/preparation_done.flag",
        pdbqt_dir="results/module3/ligands_pdbqt"
    output: list="results/module2/ligands_list.txt"
    run:
        import glob
        import os

        pdbqt_paths = sorted(glob.glob("results/module3/ligands_pdbqt/*.pdbqt"))
        ligands = [
            os.path.splitext(os.path.basename(path))[0]
            for path in sorted(glob.glob("results/module3/ligands_pdbqt/*.pdbqt"))
            for path in pdbqt_paths
        ]
        invalid_path = "invalid_ligands.txt"
        if os.path.exists(invalid_path):
            with open(invalid_path, "r") as handle:
                invalid_ligands = {line.strip() for line in handle if line.strip()}
            ligands = [ligand for ligand in ligands if ligand not in invalid_ligands]
        with open(output.list, "w") as handle:
            handle.write("\n".join(ligands))


# =========================================
# MÓDULO 3: DOCKING (HTVS)
# =========================================

# Paso inicial: Crear directorio de logs de Smina
rule init_module3_logs:
    output:
        logs_dir=directory("results/module3/logs")
    shell:
        "mkdir -p {output.logs_dir}"

# Paso intermedio: Convertir SDFs (del Modulo 2) a PDBQTs (para Smina)
rule convert_sdf_to_pdbqt:
    conda: "envs/openbabel.yaml"
    input:
        flag="results/module2/preparation_done.flag",
        sdf="results/module2/ligands_3d/{ligand}.sdf"
    output: "results/module3/ligands_pdbqt/{ligand}.pdbqt"
    shell:
        "obabel {input.sdf} -O {output} --partialcharge gasteiger"

rule run_smina:
    conda: "envs/gnina.yaml" # Smina en conda; Gnina se usa vía contenedor para rescoring
    input:
        receptor="results/module1/target_prepared.pdbqt",
        ligand="results/module3/ligands_pdbqt/{ligand}.pdbqt"
    output:
        docked="results/module3/docking/{ligand}_out.pdbqt",
        log="results/module3/logs/{ligand}.log"
    params:
        cx=config["docking"]["center_x"],
        cy=config["docking"]["center_y"],
        cz=config["docking"]["center_z"],
        sx=config["docking"]["size_x"],
        sy=config["docking"]["size_y"],
        sz=config["docking"]["size_z"]
    script: "scripts/module3_run_smina.py"

rule parse_smina_results:
    conda: "../environment.yaml"
    input:
        logs=lambda wc: expand(
            "results/module3/logs/{ligand}.log",
            ligand=get_ligands_from_list(),
        ),
        validated="results/module3/smina_outputs_validated.flag"
    output: scores="results/module3/docking_scores.csv"
    script: "scripts/module3_parse_smina_results.py"

rule validate_smina_outputs:
    conda: "../environment.yaml"
    input:
        docked=lambda wc: expand(
            "results/module3/docking/{ligand}_out.pdbqt",
            ligand=get_ligands_from_list(),
        )
    output:
        flag="results/module3/smina_outputs_validated.flag"
    script: "scripts/module3_validate_smina_outputs.py"

rule select_top_candidates:
    conda: "../environment.yaml"
    input:
        scores="results/module3/docking_scores.csv",
        library="results/module2/library_enumerated.smi"
    output:
        csv="results/module3/top_candidates.csv",
        smi="results/module3/top_candidates.smi"
    params:
        top_percent=config["docking"].get("top_candidates_percent", 5)
    script: "scripts/module3_select_top_candidates.py"

rule run_gnina_rescore:
    conda: "../environment.yaml"
    input:
        receptor="results/module1/target_prepared.pdbqt",
        top_candidates="results/module3/top_candidates.csv"
    output:
        scores="results/module3/gnina_scores.csv"
    params:
        pose_dir="results/module3/docking"
    script: "scripts/module3_run_gnina_rescore.py"
        pose_dir="results/module3/docking",
        gnina_wrapper="scripts/gnina_container_wrapper.sh"
    script: 'scripts/module3_run_gnina_rescore.py'

rule contact_filter_hits:
    conda: "../environment.yaml"
    input:
        scores="results/module3/gnina_scores.csv",
        receptor=config["evolution"]["conservation_pdb"]
    output:
        final_hits="results/module3/final_hits.csv"
    params:
        chain=config["structure"]["chain_id"],
        target_res=config["structure"]["target_residue"],
        pocket_radius=6.0,
        contact_cutoff=4.0,
        min_contacts=2,
        require_target_contact=True
    script: "scripts/module3_contact_filter.py"

# --- REGLA FINAL DE REPORTE ---
rule build_consensus_final:
    conda: "envs/vina.yaml"
    input:
        receptor="results/module1/target_prepared.pdbqt",
        top_candidates="results/module3/top_candidates.csv"
    output:
        vina_dir=directory("results/module3/vina"),
        vina_logs=directory("results/module3/vina_logs")
    params:
        ligands_dir="results/module3/ligands_pdbqt",
        center_x=config["docking"]["center_x"],
        center_y=config["docking"]["center_y"],
        center_z=config["docking"]["center_z"],
        size_x=config["docking"]["size_x"],
        size_y=config["docking"]["size_y"],
        size_z=config["docking"]["size_z"]
    script: "scripts/module3_run_vina.py"
# --- MÓDULO 3: EXPORTACIÓN PDBQT ---

rule export_ligands_pdbqt_module3:
    conda: "envs/openbabel.yaml"
    input:
        flag="results/module2/preparation_done.flag",
        sdf_dir=config["chemistry"]["prepared_dir"]
    output:
        pdbqt_dir=directory("results/module3/ligands_pdbqt")
    script: "scripts/module3_export_pdbqt.py"

# --- REGLA FINAL DE REPORTE ---

rule build_consensus_report:
    conda:
        "envs/openbabel.yaml"
    input:
        gnina="results/module3/gnina_scores.csv",
        final_hits="results/module3/final_hits.csv",
        top="results/module3/top_candidates.csv"
    output:
        consensus="results/module3/consensus_final.csv",
        report="results/final_report.txt"
    script: "scripts/module3_build_consensus.py"
