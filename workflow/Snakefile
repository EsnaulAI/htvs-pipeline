configfile: 'config/config.yaml'

# --- LÓGICA PRELIMINAR ---
USE_MMSEQS = config["evolution"].get("use_mmseqs", False)

# Detectamos los ligandos basándonos en la salida del Módulo 2 (SDFs)
# Esto asegura que Snakemake sepa qué trabajos de docking lanzar.
LIGANDS = glob_wildcards("results/module2/ligands_3d/{ligand}.sdf").ligand

# --- REGLA MAESTRA GLOBAL ---
rule all:
    input:
        # Módulo 1: Target
        "results/module1/candidate_ranking.csv",
        "results/module1/view_scene.cxc",
        "results/module1/config_updated.flag",

        # Módulo 2: Ligandos
        "results/module2/preparation_done.flag",
        "results/module2/qc_report.csv",

        # Módulo 3: Docking y Consenso
        "results/module3/docking_scores.csv",
        "results/module3/top_candidates.csv",
        "results/module3/gnina_scores.csv",
        "results/module3/consensus_final.csv",
        "results/final_report.txt"

# =========================================
# MÓDULO 1: INTELIGENCIA BIOLÓGICA
# =========================================

rule fetch_clean_pdb:
    conda: "../environment.yaml"
    output:
        pdb=config["structure"]["clean_pdb"],
        fasta="results/module1/target.fasta"
    params:
        pdb_id=config["structure"]["pdb_id"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/module1_prep_structure.py'

if not USE_MMSEQS:
    rule run_blast:
        conda: "envs/mmseqs.yaml" # Asumo que usas el mismo env o uno con biopython
        input: fasta="results/module1/target.fasta"
        output:
            xml="results/module1/blast_results.xml",
            fasta_homologs=config["evolution"]["unaligned_homologs"]
        params:
            n_hits=2000,
            e_val=0.001,
            db="nr"
        script: 'scripts/module1_run_blast.py'
else:
    rule run_mmseqs:
        conda: "envs/mmseqs.yaml"
        input: fasta="results/module1/target.fasta"
        output:
            fasta_homologs=config["evolution"]["unaligned_homologs"],
            method_log="results/module1/homolog_method.log"
        threads: 4
        script: 'scripts/module1_run_mmseqs.py'

rule parse_and_align:
    conda: "envs/mafft.yaml"
    input:
        homologs=config["evolution"]["unaligned_homologs"],
        original_fasta="results/module1/target.fasta"
    output: fasta_msa=config["evolution"]["msa_file"]
    threads: 4
    script: 'scripts/module1_parse_and_align.py'

rule msa_qc:
    conda: "../environment.yaml"
    input: msa=config["evolution"]["msa_file"]
    output: report=config["evolution"]["msa_qc_report"]
    script: 'scripts/module1_msa_qc.py'

rule map_conservation:
    conda: "../environment.yaml"
    input:
        pdb=config["structure"]["clean_pdb"],
        msa=config["evolution"]["msa_file"],
        qc_report=config["evolution"]["msa_qc_report"]
    output:
        pdb_conserved=config["evolution"]["conservation_pdb"],
        pdb_msa_map=config["evolution"]["pdb_msa_map"]
    script: 'scripts/module1_map_entropy.py'

rule run_pydca:
    conda: "envs/pydca.yaml"
    input:
        msa=config["evolution"]["msa_file"],
        pdb_msa_map=config["evolution"]["pdb_msa_map"]
    output:
        plot="results/module1/dca_distribution.png",
        report="results/module1/dca_top_contacts.csv"
    params: target_res=config["structure"]["target_residue"]
    script: 'scripts/module1_pydca.py'

rule run_coevolution_mi:
    input:
        msa=config["evolution"]["msa_file"],
        pdb_msa_map=config["evolution"]["pdb_msa_map"]
    output: plot="results/module1/coevolution_profile.png"
    params: target_res=config["structure"]["target_residue"]
    script: 'scripts/module1_coevolution_mi.py'

rule run_network_analysis:
    conda: "../environment.yaml"
    input: pdb=config["evolution"]["conservation_pdb"]
    output: report="results/module1/network_report.txt"
    params:
        target_res=config["structure"]["target_residue"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/module1_network_analysis.py'

rule run_nma:
    conda: "../environment.yaml"
    input: pdb=config["evolution"]["conservation_pdb"]
    output: plot="results/module1/nma_mobility_profile.png"
    params:
        target_res=config["structure"]["target_residue"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/module1_nma_check.py'

rule check_druggability:
    conda: "../environment.yaml"
    input: pdb=config["structure"]["clean_pdb"]
    output: report="results/module1/druggability_report.txt"
    params:
        chain=config["structure"]["chain_id"],
        target_res=config["structure"]["target_residue"]
    script: 'scripts/module1_check_druggability.py'

rule run_fpocket:
    conda: "envs/fpocket.yaml"
    input: pdb=config["structure"]["clean_pdb"]
    output: info="results/module1/pockets/target_clean_info.txt"
    shell:
        """
        fpocket -f {input.pdb}
        mkdir -p results/module1/pockets
        mv results/module1/target_clean_out/target_clean_info.txt {output.info}
        rm -rf results/module1/target_clean_out
        """

rule prepare_receptor_phys:
    conda: "envs/openbabel.yaml"
    input: pdb=config["structure"]["clean_pdb"]
    output: pdbqt="results/module1/target_prepared.pdbqt"
    shell:
        """
        set -euo pipefail
        obabel {input.pdb} -O {output.pdbqt} -xr --partialcharge gasteiger -p 7.4
        """

rule discover_best_candidate:
    conda: "../environment.yaml"
    input:
        pdb=config["evolution"]["conservation_pdb"],
        pockets="results/module1/pockets/target_clean_info.txt"
    output: csv="results/module1/candidate_ranking.csv"
    params: chain=config["structure"]["chain_id"]
    script: 'scripts/module1_discover_best_target.py'

rule update_target_config:
    conda: "../environment.yaml"
    input:
        csv="results/module1/candidate_ranking.csv",
        pdb=config["structure"]["clean_pdb"]
    output: touch("results/module1/config_updated.flag")
    params: chain=config["structure"]["chain_id"]
    script: 'scripts/bridge_update_config.py'

rule generate_viz:
    conda: "../environment.yaml"
    input: pdb=config["evolution"]["conservation_pdb"]
    output: cxc="results/module1/view_scene.cxc"
    params:
        target_res=config["structure"]["target_residue"],
        chain=config["structure"]["chain_id"]
    script: 'scripts/generate_chimerax_scene.py'


# =========================================
# MÓDULO 2: QUIMIOINFORMÁTICA
# =========================================

rule fetch_library:
    conda: "../environment.yaml"
    output: smi=config["chemistry"]["raw_library"]
    script: 'scripts/fetch_chembl_drugs.py'

rule filter_ligands:
    conda: "envs/rdkit.yaml"
    input: smi=config["chemistry"]["raw_library"]
    output:
        filtered=config["chemistry"]["filtered_library"],
        report="results/module2/filtering_report.csv",
        dedup="results/module2/library_dedup.smi"
    params:
        mw=config["chemistry"]["filters"]["mw_max"],
        logp=config["chemistry"]["filters"]["logp_max"],
        amine=config["chemistry"]["filters"]["must_have_amine"]
    script: 'scripts/module2_filter_entry.py'

rule qc_properties:
    conda: "envs/rdkit.yaml"
    input: smi=config["chemistry"]["filtered_library"]
    output: report="results/module2/qc_report.csv"
    script: 'scripts/module2_qc_properties.py'

rule enumerate_protomers:
    conda: "envs/rdkit.yaml"
    input: smi="results/module2/library_dedup.smi"
    output: enumerated="results/module2/library_enumerated.smi"
    script: 'scripts/module2_enumerate_protomers.py'

rule prepare_ligands_3d:
    conda: "envs/rdkit.yaml"
    input: smi="results/module2/library_enumerated.smi"
    output: touch("results/module2/preparation_done.flag")
    params: out_dir=config["chemistry"]["prepared_dir"]
    threads: 4
    script: 'scripts/module2_prep_3d.py'


# =========================================
# MÓDULO 3: DOCKING (HTVS)
# =========================================

# Paso intermedio: Convertir SDFs (del Modulo 2) a PDBQTs (para Smina)
rule convert_sdf_to_pdbqt:
    conda: "envs/openbabel.yaml"
    input:
        flag="results/module2/preparation_done.flag",
        sdf="results/module2/ligands_3d/{ligand}.sdf"
    output: "results/module3/ligands_pdbqt/{ligand}.pdbqt"
    shell:
        "obabel {input.sdf} -O {output} --partialcharge gasteiger"

rule run_smina:
    conda: "envs/gnina.yaml" # Smina suele venir con Gnina, o usa env propio
    input:
        receptor="results/module1/target_prepared.pdbqt",
        ligand="results/module3/ligands_pdbqt/{ligand}.pdbqt"
    output:
        docked="results/module3/docking/{ligand}_out.pdbqt",
        log="results/module3/logs/{ligand}.log"
    params:
        cx=config["docking"]["center_x"],
        cy=config["docking"]["center_y"],
        cz=config["docking"]["center_z"],
        sx=config["docking"]["size_x"],
        sy=config["docking"]["size_y"],
        sz=config["docking"]["size_z"]
    shell:
        """
        mkdir -p results/module3/docking results/module3/logs
        smina --receptor {input.receptor} --ligand {input.ligand} \
              --center_x {params.cx} --center_y {params.cy} --center_z {params.cz} \
              --size_x {params.sx} --size_y {params.sy} --size_z {params.sz} \
              --out {output.docked} --log {output.log} --cpu 1
        """

rule parse_smina_results:
    conda: "../environment.yaml"
    input:
        # Usamos expand para esperar a que TODOS los logs estén listos
        logs=expand("results/module3/logs/{ligand}.log", ligand=LIGANDS)
    output: scores="results/module3/docking_scores.csv"
    script: "scripts/module3_parse_smina_results.py"

rule select_top_candidates:
    conda: "../environment.yaml"
    input:
        scores="results/module3/docking_scores.csv",
        library="results/module2/library_enumerated.smi"
    output:
        csv="results/module3/top_candidates.csv",
        smi="results/module3/top_candidates.smi"
    params:
        top_percent=config["docking"].get("top_candidates_percent", 5)
    script: "scripts/module3_select_top_candidates.py"

rule run_gnina_rescore:
    conda: "envs/gnina.yaml"
    input:
        receptor="results/module1/target_prepared.pdbqt",
        top_candidates="results/module3/top_candidates.csv"
    output: scores="results/module3/gnina_scores.csv"
    params: pose_dir="results/module3/docking"
    script: "scripts/module3_run_gnina_rescore.py"

# --- REGLA FINAL DE REPORTE ---
rule build_consensus_final:
    conda: "../environment.yaml"
    input:
        gnina="results/module3/gnina_scores.csv",
        top="results/module3/top_candidates.csv"
    output:
        consensus="results/module3/consensus_final.csv",
        report="results/final_report.txt"
    script: "workflow/scripts/module3_build_consensus.py"
